% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ngs-fit.r
\name{ngs.fitContrastsWithAllMethods}
\alias{ngs.fitContrastsWithAllMethods}
\alias{ngs.fitContrastsWithTTEST}
\alias{ngs.fitContrastsWithLIMMA}
\alias{ngs.fitContrastsWithEDGER}
\alias{.ngs.fitContrastsWithEDGER.nodesign}
\alias{.ngs.fitContrastsWithEDGER.nodesign.pruned}
\alias{ngs.fitConstrastsWithDESEQ2}
\alias{.ngs.fitConstrastsWithDESEQ2.nodesign}
\title{ngs.fitContrastsWithAllMethods}
\usage{
ngs.fitContrastsWithAllMethods(
  counts,
  X = NULL,
  samples,
  design,
  contr.matrix,
  genes = NULL,
  prior.cpm = 1,
  prune.samples = FALSE,
  conform.output = TRUE,
  do.filter = TRUE,
  cpm.scale = 1e+06,
  remove.batch = TRUE,
  methods = c("ttest", "ttest.welch", "voom.limma", "trend.limma", "notrend.limma",
    "deseq2.wald", "deseq2.lrt", "edger.qlf", "edger.lrt"),
  correct.AveExpr = TRUE,
  custom = NULL,
  custom.name = NULL
)

ngs.fitContrastsWithTTEST(
  X,
  contr.matrix,
  design,
  method = "welch",
  conform.output = 0
)

ngs.fitContrastsWithLIMMA(
  X,
  contr.matrix,
  design,
  method = c("voom", "limma"),
  trend = TRUE,
  robust = TRUE,
  prune.samples = FALSE,
  conform.output = FALSE,
  plot = FALSE
)

ngs.fitContrastsWithEDGER(
  counts,
  group,
  contr.matrix,
  design,
  method = c("qlf", "lrt"),
  prune.samples = FALSE,
  X = NULL,
  conform.output = FALSE,
  robust = TRUE,
  plot = TRUE
)

.ngs.fitContrastsWithEDGER.nodesign(
  dge,
  contr.matrix,
  method = c("qlf", "lrt"),
  X = NULL,
  conform.output = FALSE,
  robust = TRUE,
  plot = TRUE
)

.ngs.fitContrastsWithEDGER.nodesign.pruned(
  counts,
  contr.matrix,
  group = NULL,
  method = c("qlf", "lrt"),
  X = NULL,
  conform.output = FALSE,
  robust = TRUE,
  plot = TRUE
)

ngs.fitConstrastsWithDESEQ2(
  counts,
  group,
  contr.matrix,
  design,
  X = NULL,
  genes = NULL,
  test = "Wald",
  prune.samples = FALSE,
  conform.output = FALSE
)

.ngs.fitConstrastsWithDESEQ2.nodesign(
  counts,
  contr.matrix,
  test = "Wald",
  prune.samples = FALSE,
  conform.output = FALSE,
  X = NULL
)
}
\arguments{
\item{counts}{A matrix of counts, with genes in rows and samples in columns.}

\item{X}{Covariates to include in the design matrix. Default is NULL.}

\item{samples}{A vector of sample names that match the columns in \code{counts}.}

\item{design}{The design matrix, with samples in columns.}

\item{contr.matrix}{The contrasts matrix, with contrasts in rows.}

\item{genes}{A vector of gene names that match the rows in \code{counts}. Default is NULL.}

\item{prior.cpm}{Prior counts per million. Default is 1.}

\item{prune.samples}{Whether to filter low count samples. Default is FALSE.}

\item{conform.output}{Whether to conform the output. Default is TRUE.}

\item{do.filter}{Whether to filter genes. Default is TRUE.}

\item{cpm.scale}{Counts per million scaling factor. Default is 1e6.}

\item{remove.batch}{Whether to remove batch effects. Default is TRUE.}

\item{methods}{Methods to apply. Can be one or more of:
\itemize{
  \item{\code{ttest}}{t-test}
  \item{\code{ttest.welch}}{Welch's t-test}
  \item{\code{voom.limma}}{voom + limma}
  \item{\code{trend.limma}}{limma with trend}
  \item{\code{notrend.limma}}{limma without trend}
  \item{\code{deseq2.wald}}{DESeq2 Wald test}
  \item{\code{deseq2.lrt}}{DESeq2 LRT}
  \item{\code{edger.qlf}}{edgeR QLF}
  \item{\code{edger.lrt}}{edgeR LRT}
}}

\item{correct.AveExpr}{Whether to correct for average expression. Default is TRUE.}

\item{custom}{Custom differential expression method. Default is NULL.}

\item{custom.name}{Name for custom method. Default is NULL.}
}
\value{
A list with results from each differential expression method.
}
\description{
This function fits contrasts using multiple differential expression analysis methods on count data.
It applies the methods specified in the \code{methods} argument to the count data in \code{counts}, design matrix \code{design}, and contrast matrix \code{contr.matrix}.
}
\details{
This function provides a convenient wrapper to run multiple differential expression methods on the same data.
It runs the methods specified in \code{methods} on the provided count data and design.
The results are returned in a list, with each element containing the results from one method.
Filtering, batch effect removal, and output conforming can be controlled with arguments.
Custom methods can also be added.
}
\section{Functions}{
\itemize{
\item \code{ngs.fitContrastsWithTTEST()}: Fits contrasts using t-test

\item \code{ngs.fitContrastsWithLIMMA()}: Fits contrasts using LIMMA differential expression analysis on count data.

\item \code{ngs.fitContrastsWithEDGER()}: Fit contrasts with EdgeR

\item \code{.ngs.fitContrastsWithEDGER.nodesign()}: contrasts with EdgeR without a design

\item \code{.ngs.fitContrastsWithEDGER.nodesign.pruned()}: Fit contrasts with EdgeR without a design matrix

\item \code{ngs.fitConstrastsWithDESEQ2()}: Fits contrasts using DESeq2 differential expression
analysis on count data

\item \code{.ngs.fitConstrastsWithDESEQ2.nodesign()}: Fits contrasts using DESeq2 differential expression

}}
\examples{
\dontrun{
# TODO
}
}
